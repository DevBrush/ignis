#!/usr/bin/env python3

# Copyright (C) 2015-2016, Vi Grey
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

import os
import http.server
import re
import socketserver
import sys
import termios
import threading
import tty

VERSION = "1.0.3.2"
AUTHOR = "Vi Grey (https://vigrey.com)"
HOST = "127.0.0.1"
PORT = 9999
INPUT_PATH = "."
OUTPUT_PATH = "__website__"
HELP_FLAG = False
VERSION_FLAG = False
VERBOSE_FLAG = False
HTTP_FLAG = False
LAN_FLAG = False
MOCK_FLAG = False
INCLUDE_EXTENSIONS = False
INCLUDE_HTACCESS = False


# Handles how page requests get handled in the HTTP server..
class HTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    # Handles GET requests.
    def do_GET(self):
        path = self.translate_path(self.path)
        if os.path.isdir(path):
            if len(path) > 0:
                if path[-1] != "/":
                    path += "/"
            if os.path.isfile(path[: -1] + ".html"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path[: -1] + ".html", "rb").read())
            elif os.path.isfile(path[: -1] + ".htm"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path[: -1] + ".htm", "rb").read())
            elif os.path.isfile(path + "index.html"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + "index.html", "rb").read())
            elif os.path.isfile(path + "index.htm"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + "index.htm", "rb").read())
            else:
                self.send_response(404, "File not found")
                return None
        elif not re.search("\..*$", self.path):
            if os.path.isfile(path + ".html"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + ".html", "rb").read())
            elif os.path.isfile(path + ".htm"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + ".html", "rb").read())
            else:
                self.send_response(404, "File not found")
                return None
        elif os.path.isfile(path):
            self.send_response(200)
            self.send_header("Content-type", self.guess_type(self.path))
            self.end_headers()
            self.wfile.write(open(path, "rb").read())
        else:
            self.send_response(404, "File not found")
            return None
        return

    # Handles POST requests.
    def do_POST(self):
        path = self.translate_path(self.path)
        if os.path.isdir(path):
            if len(path) > 0:
                if path[-1] != "/":
                    path += "/"
            if os.path.isfile(path[: -1] + ".html"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path[: -1] + ".html", "rb").read())
            elif os.path.isfile(path[: -1] + ".htm"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path[: -1] + ".htm", "rb").read())
            elif os.path.isfile(path + "index.html"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + "index.html", "rb").read())
            elif os.path.isfile(path + "index.htm"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + "index.htm", "rb").read())
            else:
                self.send_response(404, "File not found")
                return None
        elif not re.search("\..*$", self.path):
            if os.path.isfile(path + ".html"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + ".html", "rb").read())
            elif os.path.isfile(path + ".htm"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + ".html", "rb").read())
            else:
                self.send_response(404, "File not found")
                return None
        elif os.path.isfile(path):
            self.send_response(200)
            self.send_header("Content-type", self.guess_type(self.path))
            self.end_headers()
            self.wfile.write(open(path, "rb").read())
        else:
            self.send_response(404, "File not found")
            return None
        return

    # Removes logging.
    def log_message(self, format, *args):
        pass


# Allows reuse of port
class HandleTCPServer(socketserver.TCPServer):
    allow_reuse_address = True


# Returns a list of all of the available input files for the website build.
def get_files():
    file_list = []
    for root, dirs, files in os.walk(INPUT_PATH):
        if root[-1] == "/":
            root = root[: -1]
        if re.search("(/\.)", root) is None and OUTPUT_PATH not in root:
            for f in files:
                file_list.append(root + "/" + f)
    return file_list


# Gets the header data of each file
def get_header(file_path, content):
    header_vars = {}
    header_content = b""
    is_content_file = False
    tmp_input_path = INPUT_PATH
    if tmp_input_path[0] == "/":
        tmp_input_path = tmp_input_path[1:]
    header_vars[b"@FILEPATH"] = os.path.abspath(file_path)[len(
        tmp_input_path) + 1:].encode("utf-8")
    if not INCLUDE_EXTENSIONS:
        if len(header_vars[b"@FILEPATH"]) > 3:
            if len(header_vars[b"@FILEPATH"]) > 4:
                if header_vars[b"@FILEPATH"][-5:] == b".html":
                    header_vars[b"@FILEPATH"] = header_vars[b"@FILEPATH"][: -5]
            else:
                if header_vars[b"@FILEPATH"][-4:] == b".htm":
                    header_vars[b"@FILEPATH"] = header_vars[b"@FILEPATH"][: -4]
    if content.find(b"!-template-!") == 0:
        header_vars["@ISTEMPLATE"] = True
        return header_vars, is_content_file
    start = content.find(b"!-header\n")
    if start == 0:
        end = content[start:].find(b"\n-!\n")
        if end >= 0:
            header_content = content[9: end]
            for var in header_content.split(b"\n"):
                if var != b"":
                    key_end = var.find(b"=")
                    if key_end < 0:
                        sys.exit("ignis: incorrectly formatted header line " +
                                 var.decode("utf-8") + " in " +
                                 os.path.abspath(file_path))
                    if not re.match(b"^[A-Za-z0-9_-]*$", var[: key_end]):
                        if var[: key_end] != b"%TEMPLATE":
                            sys.exit("ignis: invalid header value name " +
                                     var[: key_end].decode("utf-8") + " in " +
                                     os.path.abspath(file_path))
                    header_vars[var[: key_end]] = var[key_end + 1:]
            is_content_file = True
            content = content[end + 4:]
            while len(content) > 0:
                if content[0] == ord(b"\n"):
                    content = content[1:]
                else:
                    break
            header_vars[b"@CONTENT"] = content
        else:
            sys.exit("ignis: header section in " + os.path.abspath(file_path) +
                     " must end with -!")
    return header_vars, is_content_file


# Goes through every file and handles reading, building and writing.
def handle_files(input_files):
    mock = ""
    if MOCK_FLAG:
        mock = "[MOCK] "
    header_list = []
    for f in input_files:
        input_file = open(f, "rb")
        if VERBOSE_FLAG:
            print(mock + "Reading " + f)
        input_content = input_file.read()
        input_content = input_content.replace(b"\r\n", b"\n")
        if VERBOSE_FLAG:
            print(mock + "Checking " + f + " for header values")
        header_vars, is_header = get_header(f, input_content)
        header_list.append((header_vars, is_header, f))
    for t in header_list:
        file_input = INPUT_PATH
        file_content = open(t[2], "rb").read()
        header_vars = t[0]
        if "@ISTEMPLATE" not in header_vars:
            if t[1]:
                tmp_output_path = OUTPUT_PATH
                tmp_template_root_path = INPUT_PATH
                if b"%TEMPLATE" in t[0]:
                    tmp_template_path = t[0][b"%TEMPLATE"].decode("utf-8")
                    if len(tmp_output_path) > 0:
                        if tmp_output_path[-1] != "/":
                            tmp_output_path += "/"
                    if len(tmp_template_root_path) > 0:
                        if tmp_template_root_path[-1] != "/":
                            tmp_template_root_path += "/"
                    if len(tmp_template_path) > 0:
                        if tmp_template_path[0] == "/":
                            tmp_template_path = tmp_template_path[1:]
                    tmp_input_path = t[2][len(tmp_template_root_path) - 1:]
                    template_path = tmp_template_root_path + tmp_template_path
                    template_file = open(template_path, "rb")
                    template_content = template_file.read()
                    template_content = template_content[12:]
                else:
                    template_content = b"[!- print {@CONTENT} -!]"
                if VERBOSE_FLAG:
                    if is_header:
                        print(mock + "Building " + tmp_output_path +
                              tmp_input_path)
                for x in range(2):
                    pointer = 0
                    while True:
                        if x == 1:
                            template_content = handle_if_nesting(
                                t[0], template_content, 0, False)
                            template_content = handle_for_nesting(
                                header_list, template_content, 0)
                            tmp_p_content = template_content
                        else:
                            t[0][b"@CONTENT"] = handle_if_nesting(
                                t[0], t[0][b"@CONTENT"], 0, False)
                            t[0][b"@CONTENT"] = handle_for_nesting(
                                header_list, t[0][b"@CONTENT"], 0)
                            tmp_p_content = t[0][b"@CONTENT"]
                        pointer_start = tmp_p_content[pointer:].find(b"[!-")
                        if pointer_start >= 0:
                            pointer_end = tmp_p_content[
                                pointer + pointer_start:].find(b"-!]")
                            if pointer_end >= 0:
                                replaced_content = tmp_p_content[
                                    pointer + pointer_start: pointer +
                                    pointer_start + pointer_end + 3]
                                tmp_p_content = (
                                    tmp_p_content[: pointer + pointer_start] +
                                    handle_variables(header_vars,
                                                     header_list,
                                                     replaced_content,
                                                     pointer_start) +
                                    tmp_p_content[
                                        pointer + pointer_start +
                                        pointer_end + 3:])
                                if x == 1:
                                    template_content = tmp_p_content
                                else:
                                    t[0][b"@CONTENT"] = tmp_p_content
                                pointer += pointer_start + 1
                            else:
                                break
                        else:
                            break
                # Remove beginning and trailing newline characters and spaces
                template_content = template_content.replace(b"\r\n", b"\n")
                template_content = remove_spaces_nl(template_content)
                file_content = template_content
            tmp_output_path = OUTPUT_PATH
            tmp_input_path = INPUT_PATH
            if tmp_output_path[-1] == "/":
                tmp_output_path = tmp_output_path[: -1]
            if tmp_input_path[0] != "/":
                tmp_input_path += "/"
            tmp_input_path = t[2][len(tmp_input_path):]
            if not MOCK_FLAG:
                os.makedirs(tmp_output_path + "/".join(
                    tmp_input_path.split("/")[: -1]), 0o755, True)
                write_file = open(tmp_output_path + tmp_input_path, "wb")
            if VERBOSE_FLAG:
                print(mock + "Writing " + tmp_output_path + tmp_input_path)
            if not MOCK_FLAG:
                write_file.write(file_content)
    if INCLUDE_HTACCESS:
        if not MOCK_FLAG:
            write_file = open(OUTPUT_PATH + "/.htaccess", "wb")
        if VERBOSE_FLAG:
            print(mock + "Writing " + OUTPUT_PATH + "/.htaccess")
        if not MOCK_FLAG:
            write_file.write(b"Options -Multiviews -Indexes\n\n" +
                             b"RewriteEngine On\n" +
                             b"RewriteBase /\n\n" +
                             b"#Allow files and directories to have the " +
                             b"same name\n" +
                             b"DirectorySlash Off\n\n" +
                             b"#Remove trailing slash\n" +
                             b"RewriteRule ^(.+?)/$ /$1 [R=301,L]\n\n" +
                             b"#Allow .html/.htm files to not include " +
                             b".html/.htm (.html takes priority!)\n" +
                             b"RewriteCond %{DOCUMENT_ROOT}/$1.html -f\n" +
                             b"RewriteRule ^(.+?)/?$ /$1.html [L]\n" +
                             b"RewriteCond %{DOCUMENT_ROOT}/$1.htm -f\n" +
                             b"RewriteRule ^(.+?)/?$ /$1.htm [L]")


# Removes spaces and new lines at the beginning and end of content
def remove_spaces_nl(content):
    while len(content) > 0:
        if (content[0] == ord("\n") or
                content[0] == ord(" ")):
            content = content[1:]
        elif (content[-1] == ord("\n") or
                content[-1] == ord(" ")):
            content = content[: -1]
        else:
            break
    return content


# Figures out if if_content should stay in the pages content or not
def handle_if(header_set, var, value_check, if_content, equal, forif):
    final_content = b""
    check_variable = b""
    check_value = b""
    error = False
    if not forif:
        if_check = b"if"
    else:
        if_check = b"forif"
    if len(var) > 1:
        if var[0] != ord("{") or var[-1] != ord("}"):
            error = True
        else:
            check_variable = var[1: -1]
    else:
        error = True
    if error:
        sys.exit("ignis: incorrectly formatted check variable in '" +
                 if_check.decode("utf-8") + "' statement")
    error = False
    if len(value_check) > 1:
        if value_check[0] != ord("\"") or value_check[-1] != ord("\""):
            error = True
        else:
            check_value = value_check[1: -1]
    else:
        error = True
    if error:
        sys.exit("ignis: incorrectly formatted check value in '" +
                 if_check.decode("utf-8") + "' statement")
    if check_variable in header_set:
        if header_set[check_variable] == check_value:
            if equal:
                final_content = if_content
        elif not equal:
            final_content = if_content
    elif not equal:
        final_content = if_content
    return final_content


# Checks to see if 'if' statement makes sense, then figures out
# if if_content should stay or be removed based on the statement.
def handle_if_string(header_set, if_content, content, if_string, forif):
    final_content = b""
    if_string = if_string.replace(b"[!-", b"")
    if_string = if_string.replace(b"-!]", b"")
    content_list = if_string.split(b" ")
    content_list = list(filter(None, content_list))
    if not forif:
        if_check = b"if"
    else:
        if_check = b"forif"
    if len(content_list) > 1:
        if content_list[0] == if_check:
            if len(content_list) > 3:
                # check if correct if statement syntax
                if ((content_list[2] == b"is" or
                     content_list[2] == b"not") and
                        (len(content_list[1]) > 1 and
                            content_list[1][0] == ord("{") and
                            content_list[1][-1] == ord("}"))):
                    if len(if_content) > 0:
                        if (if_content[0] == ord("\n") or
                                if_content[0] == ord("\r")):
                            if (len(if_content) > 1 and
                                    if_content[0] == ord("\r") and
                                    if_content[1] == ord("\n")):
                                if_content = if_content[1:]
                            if_content = if_content[1:]
                    if_end = content.find(b"-!]")
                    equal = True
                    if content_list[2] == b"not":
                        equal = False
                    if_content = handle_if(header_set, content_list[1],
                                           b" ".join(content_list[3:]),
                                           if_content, equal, forif)
                    final_content = if_content
                else:
                    sys.exit("ignis: incorrect '" + if_check.decode("utf-8") +
                             "' statement syntax")
    final_content = remove_spaces_nl(final_content)
    return final_content


# Figures out where each if statement starts and ends and if they are nesting.
def handle_if_nesting(header_set, content, pointer, forif):
    if not forif:
        if_check = b"if"
    else:
        if_check = b"forif"
    while True:
        if_exists = re.search(b"\[!-[ ]{0,}" + if_check + b" ",
                              content[pointer:])
        endif_exists = re.search(b"\[!-[ ]{0,}end" + if_check + b"[ ]{0,}-!\]",
                                 content[pointer:])
        if if_exists and endif_exists:
            if_start = if_exists.start() + pointer
            endif_start = endif_exists.start() + pointer
            if if_start < endif_start:
                content = handle_if_nesting(header_set, content, pointer +
                                            if_start - pointer + 1, forif)
            else:
                if pointer > 0:
                    if_start = (
                        re.search(b"\[!-[ ]{0,}" + if_check + b" ",
                                  content[pointer - 1:]).start() +
                        pointer)
                if_end_exists = re.search(b"-!\]", content[if_start:])
                if_end = if_end_exists.end()
                if if_end < endif_start:
                    tmp_content = content[pointer + if_end: endif_start]
                    replacement_content = handle_if_string(
                        header_set, tmp_content, content,
                        content[if_start - 1: pointer + if_end], forif)
                    pointer_start = pointer - 2
                    if replacement_content == b"":
                        if len(content[pointer + endif_exists.end():]) > 0:
                            if (content[pointer +
                                        endif_exists.end()] == ord("\n")):
                                content = (content[: pointer +
                                                   endif_exists.end()] +
                                           content[pointer +
                                                   endif_exists.end() +1:])
                        while len(content[: pointer_start]) > 0:
                            if content[pointer_start] == ord(" "):
                                pointer_start -= 1
                            else:
                                break
                    content = (content[: pointer_start + 1] +
                               replacement_content +
                               content[pointer + endif_exists.end():])
                    if pointer > 0:
                        break
                else:
                    sys.exit("ignis: incorrect '" + if_check.decode("utf-8") +
                             "' statement syntax")
        elif not if_exists and not endif_exists:
            break
        elif not if_exists:
            if_start = pointer - 1
            endif_start = endif_exists.start()
            if_end_exists = re.search(b"-!\]", content[if_start:])
            if not if_end_exists:
                sys.exit("ignis: '" + if_check.decode("utf-8") +
                         "' statement required for 'end" +
                         if_check.decode("utf-8") + "'")
            if_end = if_end_exists.end()
            if if_end < endif_start:
                tmp_content = content[pointer + if_end: pointer +
                                      endif_start]
                replacement_content = handle_if_string(
                    header_set, tmp_content, content,
                    content[pointer - 1: pointer + if_end - 1], forif)
                pointer_start = pointer - 2
                if replacement_content == b"":
                    while len(content[: pointer_start]) > 0:
                        if content[pointer_start] == ord(" "):
                            pointer_start -= 1
                        else:
                            break
                content = (content[: pointer_start + 1] +
                           replacement_content +
                           content[pointer + endif_exists.end():])
                if pointer > 0:
                    break
            else:
                sys.exit("ignis: incorrect '" + if_check.decode("utf-8") +
                         "' statement syntax")
        elif not endif_exists:
            sys.exit("ignis: [!- end" + if_check.decode("utf-8") +
                     " -!] required after '" + if_check.decode("utf-8") +
                     "' statement")
    return content


# Figure out how to handle for_content in content.
def handle_for(header_list, var, value_check, sort_var, for_content):
    final_content = b""
    header_set = []
    new_header_list = []
    sort_value = b""
    check_variable = b""
    check_value = b""
    reverse = False
    error = False
    if len(sort_var) > 1:
        if sort_var[0] == ord("-"):
            reverse = True
        if reverse:
            if len(sort_var) > 2:
                if sort_var[1] != ord("{"):
                    error = True
            else:
                error = True
        else:
            if sort_var[0] != ord("{"):
                error = True
        if sort_var[-1] != ord("}"):
            error = True
        sort_value = sort_var[1: -1]
        if reverse:
            sort_value = sort_value[1:]
    else:
        error = True
    if error:
        sys.exit("ignis: incorrectly formatted sort value in 'for' loop")
    error = False
    if len(var) > 1:
        if var[0] != ord("{") or var[-1] != ord("}"):
            error = True
        else:
            check_variable = var[1: -1]
    else:
        error = True
    if error:
        sys.exit("ignis: incorrectly formatted check variable in 'for' loop")
    error = False
    if len(value_check) > 1:
        if value_check[0] != ord("\"") or value_check[-1] != ord("\""):
            error = True
        else:
            check_value = value_check[1: -1]
    else:
        error = True
    if error:
        sys.exit("ignis: incorrectly formatted check value in 'for' loop")
    for header in header_list:
        if sort_value in header[0]:
            header_set.append(header[0][sort_value])
            new_header_list.append(header[0])
    header_set_sort = sorted(header_set, key=lambda s: s.lower())
    header_set_order = sorted(range(len(header_set)),
                              key=lambda k: header_set[k])
    if reverse:
        header_set_sort = header_set_sort[::-1]
        header_set_order = header_set_order[::-1]
    for i in header_set_order:
        if check_variable in new_header_list[i]:
            if new_header_list[i][check_variable] == check_value:
                pointer = 0
                tmp_for_content = handle_if_nesting(new_header_list[i],
                                                    for_content, 0, True)
                while True:
                    pointer_start_exists = re.search(b"\[!-[ ]{0,}forprint ",
                                                     tmp_for_content[pointer:])
                    if pointer_start_exists:
                        pointer_start = pointer_start_exists.start()
                        pointer_end = tmp_for_content[
                            pointer + pointer_start:].find(b"-!]")
                        if pointer_end >= 0:
                            replaced_content = tmp_for_content[
                                pointer + pointer_start: pointer +
                                pointer_start + pointer_end + 3]
                            tmp_for_content = (tmp_for_content.replace(
                                replaced_content, handle_print(
                                    new_header_list[i], replaced_content)))
                            pointer += pointer_start + 1
                        else:
                            break
                    else:
                        break
                final_content += tmp_for_content
    return final_content


# Checks to see if 'for' loop statement makes sense, then figures out
# how to handle for_content based on the statement.
def handle_for_string(header_list, for_content, content, for_string):
    final_content = b""
    for_string = for_string.replace(b"[!-", b"")
    for_string = for_string.replace(b"-!]", b"")
    content_list = for_string.split(b" ")
    content_list = list(filter(None, content_list))
    if len(content_list) > 1:
        if content_list[0] == b"for":
            if len(content_list) > 5:
                # check if correct for loop syntax
                sort_check = False
                if len(content_list[-1]) > 1:
                    if (content_list[-1][-1] == ord("}") and
                            (content_list[-1][0] == ord("{") or
                                content_list[-1][: 2] == b"-{")):
                        sort_check = True
                if (content_list[2] == b"is" and
                        content_list[-2] == b"by" and
                        (len(content_list[1]) > 1 and
                            content_list[1][0] == ord("{") and
                            content_list[1][-1] == ord("}")) and
                        sort_check):
                    if len(for_content) > 0:
                        if (for_content[0] == ord("\n") or
                                for_content[0] == ord("\r")):
                            if (len(for_content) > 1 and
                                    for_content[0] == ord("\r") and
                                    for_content[1] == ord("\n")):
                                for_content = for_content[1:]
                            for_content = for_content[1:]
                    for_content = handle_for(header_list, content_list[1],
                                             b" ".join(content_list[3: -2]),
                                             content_list[-1], for_content)
                    final_content += for_content
                else:
                    sys.exit("ignis: incorrect 'for' loop syntax")
    final_content = remove_spaces_nl(final_content)
    return final_content


# Figures out where each for loop starts and ends and if they are nesting.
def handle_for_nesting(header_list, content, pointer):
    while True:
        for_exists = re.search(b"\[!-[ ]{0,}for ", content[pointer:])
        endfor_exists = re.search(b"\[!-[ ]{0,}endfor[ ]{0,}-!\]",
                                  content[pointer:])
        if for_exists and endfor_exists:
            for_start = for_exists.start() + pointer
            endfor_start = endfor_exists.start() + pointer
            if for_start < endfor_start:
                content = handle_for_nesting(header_list, content, pointer +
                                             for_start - pointer + 1)
            else:
                if pointer > 0:
                    for_start = (
                        re.search(b"\[!-[ ]{0,}for ",
                                  content[pointer - 1:]).start() +
                        pointer)
                for_end_exists = re.search(b"-!\]", content[for_start:])
                for_end = for_end_exists.end()
                if for_end < endfor_start:
                    tmp_content = content[pointer + for_end: endfor_start]
                    replacement_content = handle_for_string(
                        header_list, tmp_content, content,
                        content[for_start - 1: pointer + for_end])
                    content = (content[: pointer - 1] +
                               replacement_content +
                               content[pointer + endfor_exists.end():])
                    if pointer > 0:
                        break
                else:
                    sys.exit("ignis: incorrect 'for' loop syntax")
        elif not for_exists and not endfor_exists:
            break
        elif not for_exists:
            for_start = pointer - 1
            endfor_start = endfor_exists.start()
            for_end_exists = re.search(b"-!\]", content[for_start:])
            if not for_end_exists:
                sys.exit("ignis: 'for' loop required for 'endfor' statment")
            for_end = for_end_exists.end()
            if for_end < endfor_start:
                tmp_content = content[pointer + for_end: pointer +
                                      endfor_start]
                replacement_content = handle_for_string(
                    header_list, tmp_content, content,
                    content[pointer - 1: pointer + for_end - 1])
                content = (content[: pointer - 1] +
                           replacement_content +
                           content[pointer + endfor_exists.end():])
                if pointer > 0:
                    break
            else:
                sys.exit("ignis: incorrect 'for' loop syntax")
        elif not endfor_exists:
            sys.exit("ignis: [!- endfor -!] required after 'for' loop")
    return content


# Handles [!- -!] commands.
def handle_variables(header_vars, header_list, replaced_content, index):
    final_content = b""
    replaced_content = replaced_content.replace(b"[!-", b"")
    replaced_content = replaced_content.replace(b"-!]", b"")
    content_list = replaced_content.split(b" ")
    content_list = list(filter(None, content_list))
    command = list(filter(None, replaced_content.split(b" ")))
    if len(command) > 0:
        if command[0] == b"print":
            final_content += handle_print(header_vars, replaced_content)
        elif command[0] == b"forif":
            sys.exit("ignis: 'forif' statement must be inside 'for' loop")
        elif command[0] == b"endforif":
            sys.exit("ignis: 'endforif' must be inside 'for' loop")
        else:
            sys.exit("ignis: command '[!-" +
                     replaced_content.decode("utf-8") +
                     "-!]' is not usable")
    else:
        sys.exit("ignis: command needed inside [!- -!]")
    while len(final_content) > 0:
        if final_content[-1] == ord(b"\n"):
            final_content = final_content[: -1]
        else:
            break
    return final_content


# Handles print statements in content
def handle_print(header_vars, replaced_content):
    final_content = b""
    replaced_content = replaced_content.replace(b"[!-", b"")
    replaced_content = replaced_content.replace(b"-!]", b"")
    content_list = replaced_content.split(b" ")
    content_list = list(filter(None, content_list))
    x = 0
    if len(content_list) == 2:
        while x < len(content_list):
            if len(content_list[x]) > 1:
                # handle variables in print statement
                if (content_list[x][0] == ord("{") and
                        content_list[x][-1] == ord("}")):
                    if len(content_list[x]) > 2:
                        variable = content_list[x][1: -1]
                        if variable in header_vars:
                            final_content += header_vars[variable]
            x += 1
    else:
        sys.exit("ignis: '" + content_list[0].decode("utf-8") +
                 "' statement is an incorrect length")
    return final_content


# Sets things up and then runs HTTP server.  Also allows for live rebuilding.
def handle_http(path):
    global HOST
    global VERBOSE_FLAG
    global MOCK_FLAG
    os.chdir(path)
    server = HandleTCPServer((HOST, PORT), HTTPRequestHandler)
    message = ""
    if HOST == "0.0.0.0":
        message = " (Open to LAN)"
    print("Test server at http://localhost:" + str(PORT) + message +
          "\nPress \'R\' to rebuild website." +
          "\nPress Ctrl-C to stop server.")
    thread = threading.Thread(target=handle_server, args=[server])
    thread.daemon = True
    thread.start()
    while 1:
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        if ch == chr(3):
            server.server_close()
            print("")
            break
        elif ch == "r" or ch == "R":
            VERBOSE_FLAG = False
            MOCK_FLAG = False
            handle_files(get_files())
            print("\nRebuilding Website...\n")
            print("Test server at http://localhost:" + str(PORT) + message +
                  "\nPress \'R\' to rebuild website." +
                  "\nPress Ctrl-C to stop server.")


# Starts a HTTP server at HOST:PORT with the root directory being path
def handle_server(server):
    server.serve_forever()


# Print help information
def help_print():
    print("Usage: ignis [ OPTIONS ]... [ -o <path=./__website__> ] " +
          "[ <input_path=\"./\"> ]\n\n" +
          "Options:\n"
          "  -h, --help                   Print Help (this message) and " +
          "exit\n" +
          "      --include-extensions     Include .html and .htm extensions " +
          "in @FILEPATH\n" +
          "      --include-htaccess       Include .htaccess to match ignis " +
          "server\n" +
          "  -L, --LAN                    Open test server up to local " +
          "network\n" +
          "  -M, --mock                   Run a mock website build\n" +
          "  -o, --output  <path>         Path for finished website " +
          "(path=./__website__)\n" +
          "  -P, --port  <port>           Port for finished website " +
          "(port=9999)\n" +
          "  -T, --test                   Run test web server after build\n" +
          "  -V, --verbose                Print verbose messages while " +
          "building\n"
          "  -v, --version                Print version information and " +
          "exit\n\n" +
          "Examples:\n" +
          "  ignis -o path/for/website path/to/files\n" +
          "  ignis --verbose -o example-site\n" +
          "  ignis -V -T -L -o example-site\n" +
          "  ignis -VTL\n" +
          "  ignis -VT --include-extensions\n" +
          "  ignis -TL --include-htaccess --include-extensions\n" +
          "  ignis --port 9090 -VTL\n" +
          "  ignis -MV")


# Print version information
def version_print():
    print("ignis " + VERSION)


# reads and handles flags
def main():
    global HOST
    global PORT
    global INPUT_PATH
    global OUTPUT_PATH
    global HELP_FLAG
    global VERSION_FLAG
    global VERBOSE_FLAG
    global HTTP_FLAG
    global LAN_FLAG
    global MOCK_FLAG
    global INCLUDE_EXTENSIONS
    global INCLUDE_HTACCESS
    args = sys.argv[1:]
    x = 0
    while x < len(args):
        if len(args[x]) > 2 and args[x].find("--") == 0:
            if args[x][2:] == "help":
                HELP_FLAG = True
            elif args[x][2:] == "version":
                VERSION_FLAG = True
            elif args[x][2:] == "test":
                HTTP_FLAG = True
            elif args[x][2:] == "LAN":
                LAN_FLAG = True
            elif args[x][2:] == "verbose":
                VERBOSE_FLAG = True
            elif args[x][2:] == "mock":
                MOCK_FLAG = True
            elif args[x][2:] == "port":
                if len(args) > x + 1:
                    tmp_port = args[x + 1]
                    if tmp_port.isdigit():
                        if int(tmp_port) >= 0 and int(tmp_port) < 65536:
                            PORT = int(tmp_port)
                    x += 1
                else:
                    sys.exit("ignis: no port included\nTry 'ignis " +
                             "--help' for more information.")
            elif args[x][2:] == "include-extensions":
                INCLUDE_EXTENSIONS = True
            elif args[x][2:] == "include-htaccess":
                INCLUDE_HTACCESS = True
            elif args[x][2:] == "output":
                if len(args) > x + 1:
                    OUTPUT_PATH = args[x + 1]
                    x += 1
                    break
                else:
                    sys.exit("ignis: no output path included\nTry 'ignis " +
                             "--help' for more information.")
            elif args[x][2:] != "":
                sys.exit("ignis: unrecognized option " + args[x] + "\nTry " +
                         "'ignis --help' for more information.")
        elif (len(args[x]) > 1 and args[x][0] == "-" and
              args[x].find("--") != 0):
            for y in args[x][1:]:
                if y == "h":
                    HELP_FLAG = True
                elif y == "v":
                    VERSION_FLAG = True
                elif y == "T":
                    HTTP_FLAG = True
                elif y == "L":
                    LAN_FLAG = True
                elif y == "V":
                    VERBOSE_FLAG = True
                elif y == "M":
                    MOCK_FLAG = True
                elif y == "P":
                    if len(args) > x + 1:
                        tmp_port = args[x + 1]
                        if tmp_port.isdigit():
                            if int(tmp_port) >= 0 and int(tmp_port) < 65536:
                                PORT = int(tmp_port)
                            else:
                                sys.exit("ignis: invalid port number\nTry " +
                                         "'ignis --help' for more " +
                                         "information.")
                        else:
                            sys.exit("ignis: invalid port number\nTry " +
                                     "'ignis --help' for more information.")
                        x += 1
                    else:
                        sys.exit("ignis: no port included\nTry 'ignis " +
                                 "--help' for more information.")
                elif len(args[x][1:]) == 1 and y == "o":
                    if len(args) > x + 1:
                        OUTPUT_PATH = args[x + 1]
                        x += 1
                        break
                    else:
                        sys.exit("ignis: no output path included\nTry " +
                                 "'ignis --help' for more information.")
                else:
                    sys.exit("ignis: unrecognized option " + args[x] +
                             "\nTry 'ignis --help' for more information.")
        elif ("--".find(args[x]) == 0 and x != 0) or "--".find(args[x]) != 0:
            if x == len(args) - 1:
                INPUT_PATH = args[x]
            else:
                sys.exit("ignis: invalid option -- '" + args[x] +
                         "\nTry 'ignis --help' for more information.")
        x += 1
    if HELP_FLAG or VERSION_FLAG:
        if HELP_FLAG:
            help_print()
        else:
            version_print()
        sys.exit(0)
    if MOCK_FLAG:
        if HTTP_FLAG:
            sys.exit("ignis: --test must NOT be included to use mock flag\n" +
                     "Try 'ignis --help' for more information.")
        elif LAN_FLAG:
            sys.exit("ignis: --LAN must NOT be included to use mock flag\n" +
                     "Try 'ignis --help' for more information.")
    if LAN_FLAG and not HTTP_FLAG:
        sys.exit("ignis: --test must be included to use LAN flag\n" +
                 "Try 'ignis --help' for more information.")
    INPUT_PATH = os.path.abspath(INPUT_PATH)
    OUTPUT_PATH = os.path.abspath(OUTPUT_PATH)
    if INPUT_PATH == OUTPUT_PATH:
        sys.exit("ignis: input path and output path cannot be the same path")
    if INPUT_PATH[-1] == "/":
        INPUT_PATH = INPUT_PATH[: -1]
    handle_files(get_files())
    if HTTP_FLAG:
        if VERBOSE_FLAG:
            print("")
        os.makedirs(OUTPUT_PATH, 0o755, True)
        if LAN_FLAG:
            HOST = "0.0.0.0"
        handle_http(OUTPUT_PATH)

# Start ignis
if __name__ == "__main__":
    main()
