#!/usr/bin/env python3

# Copyright (C) 2015, Dev Brush Technology
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

import os
import http.server
import re
import socketserver
import sys
import termios
import threading
import tty

VERSION = "1.0.0.0"
AUTHOR = "Dev Brush Technology (http://devbrush.com)"
HOST = "127.0.0.1"
PORT = 9999
INPUT_PATH = "."
OUTPUT_PATH = "__website__"


class HTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        path = self.translate_path(self.path)
        if not re.search("\..*$", self.path):
            if os.path.isfile(path + ".html"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + ".html", "rb").read())
            elif os.path.isfile(path + ".htm"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + ".html", "rb").read())
            else:
                self.send_response(404, "File not found")
                return None
        elif os.path.isdir(path):
            if os.path.isfile(path + "index.html"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + "index.html", "rb").read())
            elif os.path.isfile(path + "index.htm"):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(open(path + "index.htm", "rb").read())
            else:
                self.send_response(404, "File not found")
                return None
        elif os.path.isfile(path):
            self.send_response(200)
            self.send_header("Content-type", self.guess_type(self.path))
            self.end_headers()
            self.wfile.write(open(path, "rb").read())
        else:
            self.send_response(404, "File not found")
            return None
        return

    def log_message(self, format, *args):
        pass


class HandleTCPServer(socketserver.TCPServer):
    allow_reuse_address = True


def get_files():
    file_list = []
    for root, dirs, files in os.walk(INPUT_PATH):
        if root[-1] == "/":
            root = root[: -1]
        if re.search("(/\.)", root) is None and OUTPUT_PATH not in root:
            for f in files:
                file_list.append(root + "/" + f)
    return file_list


def handle_nesting(header_list, content, pointer):
    while True:
        for_exists = re.search(b"\[!-[ ]{0,}for", content[pointer:])
        endfor_exists = re.search(b"\[!-[ ]{0,}endfor[ ]{0,}-!\]",
                                  content[pointer:])
        if for_exists and endfor_exists:
            for_start = for_exists.start() + pointer
            endfor_start = endfor_exists.start() + pointer
            if for_start < endfor_start:
                content = handle_nesting(header_list, content, pointer +
                                         for_start - pointer + 1)
            else:
                if pointer > 0:
                    for_start = (
                        re.search(b"\[!-[ ]{0,}for",
                                  content[pointer - 1:]).start() +
                        pointer)
                for_end_exists = re.search(b"-!\]", content[for_start:])
                for_end = for_end_exists.end()
                if for_end < endfor_start:
                    tmp_content = content[pointer + for_end: endfor_start]
                    replacement_content = handle_for_string(
                        header_list, tmp_content, content,
                        content[for_start - 1: pointer + for_end])
                    content = (content[: pointer - 1] +
                               replacement_content +
                               content[pointer + endfor_exists.end():])
                    if pointer > 0:
                        break
                else:
                    sys.exit("ignis: incorrect 'for' loop syntax")
        elif not for_exists and not endfor_exists:
            break
        elif not for_exists:
            for_start = pointer - 1
            endfor_start = endfor_exists.start()
            for_end_exists = re.search(b"-!\]", content[for_start:])
            if not for_end_exists:
                sys.exit("ignis: 'for' loop required for 'endfor' statment")
            for_end = for_end_exists.end()
            if for_end < endfor_start:
                tmp_content = content[pointer + for_end: pointer +
                                      endfor_start]
                replacement_content = handle_for_string(
                    header_list, tmp_content, content,
                    content[pointer - 1: pointer + for_end - 1])
                content = (content[:pointer - 1] +
                           replacement_content +
                           content[pointer + endfor_exists.end():])
                if pointer > 0:
                    break
            else:
                sys.exit("ignis: incorrect 'for' loop syntax")
        elif not endfor_exists:
            sys.exit("ignis: [!- endfor -!] required after 'for' loop")
    return content


def handle_for_string(header_list, for_content, content, for_string):
    final_content = b""
    for_string = for_string.replace(b"[!-", b"")
    for_string = for_string.replace(b"-!]", b"")
    content_list = for_string.split(b" ")
    content_list = list(filter(None, content_list))
    if len(content_list) > 1:
        if content_list[0] == b"for":
            if len(content_list) > 5:
                # check if correct for loop syntax
                sort_check = False
                if len(content_list[-1]) > 1:
                    if (content_list[-1][-1] == ord("}") and
                            (content_list[-1][0] == ord("{") or
                                content_list[-1][: 2] == b"-{")):
                        sort_check = True
                if (content_list[2] == b"is" and
                        content_list[-2] == b"by" and
                        (len(content_list[1]) > 1 and
                            content_list[1][0] == ord("{") and
                            content_list[1][-1] == ord("}")) and
                        sort_check):
                    for_end = content.find(b"-!]")
                    if len(for_content) > 0:
                        if (for_content[0] == ord("\n") or
                                for_content[0] == ord("\r")):
                            if (len(for_content) > 1 and
                                    for_content[0] == ord("\r") and
                                    for_content[1] == ord("\n")):
                                for_content = for_content[1:]
                            for_content = for_content[1:]
                    for_content = handle_for(header_list, content_list[1],
                                             b" ".join(content_list[3: -2]),
                                             content_list[-1], for_content)
                    final_content += for_content
                else:
                    sys.exit("ignis: incorrect 'for' loop syntax")
    return final_content


def handle_files(input_files, verbose, mock_flag):
    mock = ""
    if mock_flag:
        mock = "[MOCK] "
    header_list = []
    for f in input_files:
        input_file = open(f, "rb")
        if verbose:
            print(mock + "Reading " + f)
        input_content = input_file.read()
        input_content = input_content.replace(b"\r\n", b"\n")
        if verbose:
            print(mock + "Checking " + f + " for header values")
        header_vars, is_header = get_header(f, input_content)
        header_list.append((header_vars, is_header))
    for t in header_list:
        file_content = open(t[0][b"@FILEPATH"], "rb").read()
        header_vars = t[0]
        if "@ISTEMPLATE" not in header_vars:
            if t[1]:
                tmp_output_path = OUTPUT_PATH
                tmp_input_path = INPUT_PATH
                tmp_template_root_path = INPUT_PATH
                tmp_template_path = t[0][b"%TEMPLATE"].decode("utf-8")
                if tmp_output_path[-1] != "/":
                    tmp_output_path += "/"
                if tmp_template_root_path[-1] != "/":
                    tmp_template_root_path += "/"
                if tmp_input_path[0] == "/":
                    tmp_input_path = tmp_input_path[1:]
                if tmp_template_path[0] == "/":
                    tmp_template_path = tmp_template_path[1:]
                tmp_input_path = header_vars[b"@FILEPATH"].decode("utf-8")
                template_path = (tmp_template_root_path + tmp_template_path)
                template_file = open(template_path, "rb")
                template_content = template_file.read()
                template_content = template_content[12:]
                if verbose:
                    print(mock + "Building " + tmp_output_path +
                          tmp_input_path)
                for x in range(2):
                    pointer = 0
                    while True:
                        if x == 1:
                            tmp_p_content = template_content
                        else:
                            t[0][b"@CONTENT"] = handle_nesting(
                                header_list, t[0][b"@CONTENT"], 0)
                            tmp_p_content = t[0][b"@CONTENT"]
                        pointer_start = tmp_p_content[pointer:].find(b"[!-")
                        if pointer_start >= 0:
                            pointer_end = tmp_p_content[
                                pointer + pointer_start:].find(b"-!]")
                            if pointer_end >= 0:
                                replaced_content = tmp_p_content[
                                    pointer + pointer_start: pointer +
                                    pointer_start + pointer_end + 3]
                                tmp_p_content = (
                                    tmp_p_content[: pointer + pointer_start] +
                                    handle_variables(header_vars,
                                                     header_list,
                                                     replaced_content,
                                                     pointer_start) +
                                    tmp_p_content[
                                        pointer + pointer_start +
                                        pointer_end + 3:])
                                if x == 1:
                                    template_content = tmp_p_content
                                else:
                                    t[0][b"@CONTENT"] = tmp_p_content
                                pointer += pointer_start + pointer_end + 3
                            else:
                                break
                        else:
                            break
                # Remove beginning and trailing newline characters and spaces
                template_content = template_content.replace(b"\r\n", b"\n")
                while len(template_content) > 0:
                    if (template_content[0] == ord("\n") or
                            template_content[0] == ord(" ")):
                        template_content = template_content[1:]
                    elif (template_content[-1] == ord("\n") or
                            template_content[-1] == ord(" ")):
                        template_content = template_content[: -1]
                    else:
                        break
                file_content = template_content
            tmp_output_path = OUTPUT_PATH
            tmp_input_path = INPUT_PATH
            if tmp_output_path[-1] != "/":
                tmp_output_path += "/"
            if tmp_input_path[0] == "/":
                tmp_input_path = tmp_input_path[1:]
            tmp_input_path = header_vars[b"@FILEPATH"].decode("utf-8")
            if not mock_flag:
                os.makedirs(tmp_output_path + "/".join(
                    tmp_input_path.split("/")[: -1]), 0o755, True)
                write_file = open(tmp_output_path + tmp_input_path, "wb")
            if verbose:
                print(mock + "Writing " + tmp_output_path + tmp_input_path)
            if not mock_flag:
                write_file.write(file_content)


def handle_for(header_list, var, value_check, sort_var, for_content):
    final_content = b""
    header_set = []
    new_header_list = []
    sort_value = b""
    check_variable = b""
    check_value = b""
    reverse = False
    error = False
    if len(sort_var) > 1:
        if sort_var[0] == ord("-"):
            reverse = True
        if reverse:
            if len(sort_var) > 2:
                if sort_var[1] != ord("{"):
                    error = True
            else:
                error = True
        else:
            if sort_var[0] != ord("{"):
                error = True
        if sort_var[-1] != ord("}"):
            error = True
        sort_value = sort_var[1: -1]
        if reverse:
            sort_value = sort_value[1:]
    else:
        error = True
    if error:
        sys.exit("ignis: incorrectly formatted sort value in 'for' loop")
    error = False
    if len(var) > 1:
        if var[0] != ord("{") or var[-1] != ord("}"):
            error = True
        else:
            check_variable = var[1: -1]
    else:
        error = True
    if error:
        sys.exit("ignis: incorrectly formatted check variable in 'for' loop")
    error = False
    if len(value_check) > 1:
        if value_check[0] != ord("\"") or value_check[-1] != ord("\""):
            error = True
        else:
            check_value = value_check[1: -1]
    else:
        error = True
    if error:
        sys.exit("ignis: incorrectly formatted check value in 'for' loop")
    for header in header_list:
        if sort_value in header[0]:
            header_set.append(header[0][sort_value])
            new_header_list.append(header[0])
    header_set_sort = sorted(header_set, key=lambda s: s.lower())
    header_set_order = sorted(range(len(header_set)),
                              key=lambda k: header_set[k])
    if reverse:
        header_set_sort = header_set_sort[::-1]
        header_set_order = header_set_order[::-1]
    for i in header_set_order:
        if check_variable in new_header_list[i]:
            if new_header_list[i][check_variable] == check_value:
                pointer = 0
                tmp_for_content = for_content
                while True:
                    pointer_start = tmp_for_content[pointer:].find(b"[!-")
                    if pointer_start >= 0:
                        pointer_end = tmp_for_content[
                            pointer + pointer_start:].find(b"-!]")
                        if pointer_end >= 0:
                            replaced_content = tmp_for_content[
                                pointer + pointer_start: pointer +
                                pointer_start + pointer_end + 3]
                            #TODO handle_if
                            tmp_for_content = (tmp_for_content.replace(
                                replaced_content, handle_print(
                                    new_header_list[i], replaced_content)))
                            pointer += pointer_start + pointer_end + 3
                        else:
                            break
                    else:
                        break
                final_content += tmp_for_content
    return final_content


def handle_print(header_vars, replaced_content):
    final_content = b""
    replaced_content = replaced_content.replace(b"[!-", b"")
    replaced_content = replaced_content.replace(b"-!]", b"")
    content_list = replaced_content.split(b" ")
    content_list = list(filter(None, content_list))
    x = 0
    while x < len(content_list):
        if len(content_list[x]) > 1:
            # handle variables
            if (content_list[x][0] == ord("{") and
                    content_list[x][-1] == ord("}")):
                if len(content_list[x]) > 2:
                    variable = content_list[x][1: -1]
                    if x > 0:
                        if content_list[x - 1] == b"print":
                            if variable in header_vars:
                                print(header_vars)
                                print(variable)
                                final_content += header_vars[variable]
                    else:
                        sys.exit("ignis: command needed before variable " +
                              variable.decode("utf-8") + " in " +
                              header_vars[b"@FILEPATH"].decode("utf-8"))
        x += 1
    return final_content


def handle_variables(header_vars, header_list, replaced_content, index):
    final_content = b""
    replaced_content = replaced_content.replace(b"[!-", b"")
    replaced_content = replaced_content.replace(b"-!]", b"")
    content_list = replaced_content.split(b" ")
    content_list = list(filter(None, content_list))
    final_content += handle_print(header_vars, replaced_content)
    if len(final_content) > 0:
        while final_content[-1] == ord(b"\n"):
            final_content = final_content[: -1]
    return final_content


def get_header(file_path, content):
    header_vars = {}
    header_content = b""
    is_content_file = False
    tmp_input_path = INPUT_PATH
    if tmp_input_path[0] == "/":
        tmp_input_path = tmp_input_path[1:]
    header_vars[b"@FILEPATH"] = os.path.abspath(file_path)[len(
        tmp_input_path) + 2:].encode("utf-8")
    if content.find(b"!-template-!") == 0:
        header_vars["@ISTEMPLATE"] = True
        return header_vars, is_content_file
    start = content.find(b"!-header\n")
    if start == 0:
        end = content[start:].find(b"\n-!\n")
        if end >= 0:
            header_content = content[9: end]
            for var in header_content.split(b"\n"):
                if var != b"":
                    key_end = var.find(b"=")
                    if key_end < 0:
                        sys.exit("ignis: incorrectly formatted header line " +
                              var.decode("utf-8") + " in " +
                              os.path.abspath(file_path))
                    if not re.match(b"^[A-Za-z0-9_-]*$", var[: key_end]):
                        if var[: key_end] != b"%TEMPLATE":
                            sys.exit("ignis: invalid header value name " +
                                  var[: key_end].decode("utf-8") + " in " +
                                  os.path.abspath(file_path))
                    header_vars[var[: key_end]] = var[key_end + 1:]
            if b"%TEMPLATE" not in header_vars:
                sys.exit("ignis: %TEMPLATE required as a header line in " +
                      os.path.abspath(file_path))
            is_content_file = True
            content = content[end + 4:]
            while len(content) > 0:
                if content[0] == ord(b"\n"):
                    content = content[1:]
                else:
                    break
            header_vars[b"@CONTENT"] = content
        else:
            sys.exit("ignis: header section in " + os.path.abspath(file_path) +
                  " must end with -!")
    return header_vars, is_content_file


# Starts a HTTP server at HOST:PORT with the root directory being path
def handle_server(server):
    server.serve_forever()


def handle_http(path):
    os.chdir(path)
    global HOST
    server = HandleTCPServer((HOST, PORT), HTTPRequestHandler)
    message = ""
    if HOST == "0.0.0.0":
        message = " (Open to LAN)"
    print("Test server at http://localhost:" + str(PORT) + message +
          "\nPress \'R\' to rebuild website." +
          "\nPress Ctrl-C to stop server.")
    thread = threading.Thread(target=handle_server, args=[server])
    thread.daemon = True
    thread.start()
    while 1:
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        if ch == chr(3):
            server.server_close()
            print("")
            break
        elif ch == "r" or ch == "R":
            handle_files(get_files(), False, False)
            print("\nRebuilding Website...\n")
            print("Test server at http://localhost:" + str(PORT) + message +
                  "\nPress \'R\' to rebuild website." +
                  "\nPress Ctrl-C to stop server.")


def help_print():
    print("Usage: ignis [ OPTIONS ]... [ -o <path=./__website__> ] " +
          "[ <input_path=\"./\"> ]\n\n" +
          "Options:\n"
          "  -h, --help               Print Help (this message) and exit\n" +
          "  -L, --LAN                Open test server up to local network\n"
          "  -M, --mock               Run a mock website build\n" +
          "  -o, --output  <path>     Output path for finished website " +
          "(path=./__website__)\n" +
          "  -P, --port  <port>       Port for finished website " +
          "(port=9999)\n" +
          "  -T, --test               Run test web server after build\n" +
          "  -V, --verbose            Print verbose messages while " +
          "building\n"
          "  -v, --version            Print version information and exit\n\n" +
          "Examples:\n" +
          "  ignis -o path/for/website path/to/files\n" +
          "  ignis --verbose -o example-site\n" +
          "  ignis -V -T -L -o example-site\n" +
          "  ignis -VTL\n" +
          "  ignis --port 9090 -VTL\n" +
          "  ignis -MV")


def version_print():
    print("ignis " + VERSION)


def main():
    global HOST
    global PORT
    global INPUT_PATH
    global OUTPUT_PATH
    help_flag = False
    version_flag = False
    verbose_flag = False
    http_flag = False
    lan_flag = False
    mock_flag = False
    verbose = False
    args = sys.argv[1:]
    x = 0
    while x < len(args):
        if len(args[x]) > 2 and args[x].find("--") == 0:
            if args[x][2:] == "help":
                help_flag = True
            elif args[x][2:] == "version":
                version_flag = True
            elif args[x][2:] == "test":
                http_flag = True
            elif args[x][2:] == "LAN":
                lan_flag = True
            elif args[x][2:] == "verbose":
                verbose_flag = True
            elif args[x][2:] == "mock":
                mock_flag = True
            elif args[x][2:] == "port":
                if len(args) > x + 1:
                    tmp_port = args[x + 1]
                    if tmp_port.isdigit():
                        if int(tmp_port) >= 0 and int(tmp_port) < 65536:
                            PORT = int(tmp_port)
                    x += 1
                else:
                    sys.exit("ignis: no port included\nTry 'ignis " +
                          "--help' for more information.")
            elif args[x][2:] == "output":
                if len(args) > x + 1:
                    OUTPUT_PATH = args[x + 1]
                    x += 1
                    break
                else:
                    sys.exit("ignis: no output path included\nTry 'ignis " +
                          "--help' for more information.")
            elif args[x][2:] != "":
                sys.exit("ignis: unrecognized option " + args[x] + "\nTry " +
                      "'ignis --help' for more information.")
        elif (len(args[x]) > 1 and args[x][0] == "-" and
              args[x].find("--") != 0):
            for y in args[x][1:]:
                if y == "h":
                    help_flag = True
                elif y == "v":
                    version_flag = True
                elif y == "T":
                    http_flag = True
                elif y == "L":
                    lan_flag = True
                elif y == "V":
                    verbose_flag = True
                elif y == "M":
                    mock_flag = True
                elif y == "P":
                    if len(args) > x + 1:
                        tmp_port = args[x + 1]
                        if tmp_port.isdigit():
                            if int(tmp_port) >= 0 and int(tmp_port) < 65536:
                                PORT = int(tmp_port)
                            else:
                                sys.exit("ignis: invalid port number\nTry " +
                                      "'ignis --help' for more information.")
                        else:
                            sys.exit("ignis: invalid port number\nTry 'ignis " +
                                  "--help' for more information.")
                        x += 1
                    else:
                        sys.exit("ignis: no port included\nTry 'ignis " +
                              "--help' for more information.")
                elif len(args[x][1:]) == 1 and y == "o":
                    if len(args) > x + 1:
                        OUTPUT_PATH = args[x + 1]
                        x += 1
                        break
                    else:
                        sys.exit("ignis: no output path included\nTry 'ignis " +
                              "--help' for more information.")
                else:
                    sys.exit("ignis: unrecognized option " + args[x] +
                             "\nTry 'ignis --help' for more information.")
        elif ("--".find(args[x]) == 0 and x != 0) or "--".find(args[x]) != 0:
            if x == len(args) - 1:
                INPUT_PATH = args[x]
            else:
                sys.exit("ignis: invalid option -- '" + args[x] +
                      "\nTry 'ignis --help' for more information.")
        x += 1
    if help_flag or version_flag:
        if help_flag:
            help_print()
        else:
            version_print()
        sys.exit(0)
    if mock_flag:
        if http_flag:
            sys.exit("ignis: --test must NOT be included to use mock flag\n" +
                  "Try 'ignis --help' for more information.")
        elif lan_flag:
            sys.exit("ignis: --LAN must NOT be included to use mock flag\n" +
                  "Try 'ignis --help' for more information.")
    if lan_flag and not http_flag:
        sys.exit("ignis: --test must be included to use LAN flag\n" +
              "Try 'ignis --help' for more information.")
    if verbose_flag:
        verbose = True
    INPUT_PATH = os.path.abspath(INPUT_PATH)
    OUTPUT_PATH = os.path.abspath(OUTPUT_PATH)
    if INPUT_PATH == OUTPUT_PATH:
        sys.exit("ignis: input path and output path cannot be the same path")
    if INPUT_PATH[-1] == "/":
        INPUT_PATH = INPUT_PATH[: -1]
    handle_files(get_files(), verbose, mock_flag)
    if http_flag:
        if verbose:
            print("")
        os.makedirs(OUTPUT_PATH, 0o755, True)
        if lan_flag:
            HOST = "0.0.0.0"
        handle_http(OUTPUT_PATH)

if __name__ == "__main__":
    main()
